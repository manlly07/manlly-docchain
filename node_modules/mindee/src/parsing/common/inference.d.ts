import { StringDict } from "../common";
import { ExtraField } from "./extras/extras";
import { Page } from "./page";
import type { Prediction } from "./prediction";
import { Product } from "./product";
export declare abstract class Inference<DocT extends Prediction = Prediction, PageT extends DocT = DocT> {
    isRotationApplied?: boolean;
    product: Product;
    pages: Page<PageT>[];
    prediction: DocT;
    extras?: ExtraField[];
    endpointName?: string;
    endpointVersion?: string;
    constructor(rawPrediction: StringDict);
    toString(): string;
    static cleanOutString(outStr: string): string;
}
export declare class InferenceFactory {
    /**
     * Builds a blank product of the given type & sends back the endpointName & endpointVersion parameters of OTS classes.
     * Note: this is needed to avoid passing anything other than the class of the object to the parse()/enqueue() call.
     * @param inferenceClass Class of the product we are using
     * @returns {Inference} An empty instance of a given product.
     */
    static getEndpoint<T extends Inference>(inferenceClass: new (httpResponse: StringDict) => T): [string, string];
}
